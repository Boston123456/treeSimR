---
title: "README"
date: 
output: md_document
---

```{r set-options, echo=FALSE, cache=FALSE}
options(width = 1000)
```


# `treeSimR`

An R package for easy forward simulating probability decision trees, calculating cost-effectiveness and PSA.

Currently contains functions to:

* read-in and check tree object
* simulate final expected outcomes
* Monte-Carlo simulate multiple simulations

_TODO_

- [ ] iteratively collapse expected outcome (from right to left)
- [ ] iteratively collapse chance nodes (from right to left)
- [ ] optimal decision function (iterative from right to left)
- [ ] plotting functions: C-E plane, C-E curve, risk profile (with uncertainty), tornado, spider, ...


The package leans heavily on the `data.tree` package,
(introduction [here](https://cran.r-project.org/web/packages/data.tree/vignettes/data.tree.html) and examples [here](https://cran.r-project.org/web/packages/data.tree/vignettes/applications.html) ).



## Installing `treeSimR`

To install the development version from github:
```{r eval=FALSE}
library(devtools)
install_github("n8thangreen/treeSimR")
```

Then, to load the package, use:
```{r eval=FALSE}
library("treeSimR")
```



## Read-in trees

```{r load packages, echo=FALSE}
library(yaml)
library(data.tree)
devtools::load_all(".")
```


The raw decision tree file is a tab-spaced file such as the following:

```{r eval=FALSE}
sink("raw data/LTBI_dtree-cost-distns.yaml")

cat("
    name: LTBI screening cost
    type: decision
    distn: gamma
    mean: 1
    sd: 1
    Screening:
      distn: gamma
      mean: 1
      sd: 1
      type: chance
      LTBI:
        p: 0.25
        distn: gamma
        mean: 1
        sd: 1
        type: chance
        Not GP registered:
          type: terminal
          p: 0.4
          distn: gamma
          mean: 1
          sd: 1
        GP registered:
          type: chance
          p: 0.4
          distn: gamma
          mean: 1
          sd: 1
          Not Agree to Screen:
            p: 0.6
            type: terminal
            distn: gamma
            mean: 1
            sd: 1
          Agree to Screen:
            p: 0.6
            type: chance
            distn: gamma
            mean: 1
            sd: 1
            Test Negative:
              type: terminal
              p: 0.7
              distn: gamma
              mean: 1
              sd: 1
            Test Positive:
              type: chance
              p: 0.7
              distn: gamma
              mean: 1
              sd: 1
              Not Start Treatment:
                type: terminal
                p: 0.3
                distn: gamma
                mean: 1
                sd: 1
              Start Treatment:
                type: chance
                p: 0.3
                distn: gamma
                mean: 1
                sd: 1
                Complete Treatment:
                  type: terminal
                  p: 0.75
                  distn: gamma
                  mean: 1
                  sd: 1
                Not Complete Treatment:
                  type: terminal
                  p: 0.75
                  distn: gamma
                  mean: 1
                  sd: 1
      non-LTBI:
        p: 0.25
        distn: gamma
        mean: 1
        sd: 1
        type: chance
        Not GP registered:
          type: terminal
          p: 0.4
          distn: gamma
          mean: 1
          sd: 1
        GP registered:
          type: terminal
          p: 0.4
          distn: gamma
          mean: 1
          sd: 1
          Not Agree to Screen:
            p: 0.6
            type: chance
            distn: gamma
            mean: 1
            sd: 1
          Agree to Screen:
            p: 0.6
            type: chance
            distn: gamma
            mean: 1
            sd: 1
            Test Negative:
              type: terminal
              p: 0.7
              distn: gamma
              mean: 1
              sd: 1
            Test Positive:
              type: terminal
              p: 0.7
              distn: gamma
              mean: 1
              sd: 1
              Not Start Treatment:
                type: terminal
                p: 0.3
                distn: gamma
                mean: 1
                sd: 1
              Start Treatment:
                type: terminal
                p: 0.3
                distn: gamma
                mean: 1
                sd: 1
                Complete Treatment:
                  type: terminal
                  p: 0.75
                  distn: gamma
                  mean: 1
                  sd: 1
                Not Complete Treatment:
                  type: terminal
                  p: 0.75
                  distn: gamma
                  mean: 1
                  sd: 1
    No Screening:
      p: 0.25
      distn: gamma
      mean: 1
      sd: 1
      type: chance
      LTBI:
        type: terminal
        p: 0.4
        distn: gamma
        mean: 1
        sd: 1
      non-LTBI:
        p: 0.6
        type: terminal
        distn: gamma
        mean: 1
        sd: 1
    ", fill=TRUE)
sink()
```


We save this to a .yaml text file and then read it in as a yaml file to a data.tree object using the yaml and data.tree packages. This is then represented as a list in R.

```{r}
# osList <- yaml.load(yaml)
osList <- yaml.load_file("raw data/LTBI_dtree-cost-distns.yaml")
osNode <- as.Node(osList)
osNode
```

Better still, use the treeSimR package function to do this, checking for tree integrity and defining an additional costeffectiveness.tree class.

```{r}
osNode <- treeSimR::create.costeffectiveness.tree(yaml_tree = "raw data/LTBI_dtree-cost-distns.yaml")
print(osNode, "type", "p", "distn", "mean", "sd")
```

A neat way of exploring the tree is with the `listviewer` package widget.

```{r eval=FALSE}
library(listviewer)
l <- ToListSimple(osNode)
jsonedit(l)
```


## Simulate a scenario

We can now sample values for each branch, given the distributions defined for each.
This could be the cost or health detriment.

```{r}
rpayoff <- osNode$Get(sampleNode)
osNode$Set(payoff = rpayoff)
print(osNode, "type", "p", "distn", "mean", "sd", "payoff")
```

Now given the sampled values, e.g. cost, and the probabilities, we can calculate the expected values at each node, from leaf to root.

```{r}
osNode$Do(payoff, traversal = "post-order", filterFun = isNotLeaf)

print(osNode, "type", "p", "distn", "mean", "sd", "payoff")
```

Similarly to above, we have created a better wrapper function to perform these steps:

```{r}
osNode <- calc.expectedValues(osNode)
print(osNode, "type", "p", "distn", "mean", "sd", "payoff")
```



## Monte Carlo forward simulation

We are now in a position to do a probability sensitivity analysis (PSA) and calculate multiple realisations for specific nodes e.g. those at which a decision is to be made.

```{r}
MonteCarlo.expectedValues(osNode, n=100)
```


## Pathway Probabilities

To feed into a compartmental model like a Markov model we need state probabilities.
That is, the probability of ending-up in the one of the terminal state of the tree that are also starting states for the other model.
These are calculated by taking the product of the probabilities along each pathway from root to leaf.

Once again, we've written a function to do this, which we can append to the the tree. Below we give the terminal states in a dataframe.

```{r}
path_probs <- calc.pathway_probs(osNode)
osNode$Set(path_probs = path_probs)

terminal_states <- data.frame(pathname = osNode$Get('pathString', filterFun = isLeaf),
                              path_probs = osNode$Get('path_probs', filterFun = isLeaf))
terminal_states
```


Specifically, the starting state probabilities of the subsequent compartmental model are for aggregated sub-populations.
We can simply sum over these in an ad-hoc way:

```{r}
startstate_prob <- matrix(NA, nrow = 3, ncol = 2,
                          dimnames = list(c("<40k","40-150k",">150k"), c("LTBI","nonLTBI")))

startstate.LTBI <- grepl("/Complete Treatment", x = terminal_states$pathname) | grepl("non-LTBI", x = terminal_states$pathname)

startstate_prob["<40k","nonLTBI"] <- sum(terminal_states$path_probs[grepl("under 40k cob incidence", x = terminal_states$pathname) &
                                                                  startstate.LTBI])

startstate_prob["<40k","LTBI"] <- sum(terminal_states$path_probs[grepl("under 40k cob incidence", x = terminal_states$pathname) &
                                                               !startstate.LTBI])

startstate_prob["40-150k","nonLTBI"] <- sum(terminal_states$path_probs[grepl("40-150k cob incidence", x = terminal_states$pathname) &
                                                                     startstate.LTBI])

startstate_prob["40-150k","LTBI"] <- sum(terminal_states$path_probs[grepl("40-150k cob incidence", x = terminal_states$pathname) &
                                                                  !startstate.LTBI])

startstate_prob[">150k","nonLTBI"] <- sum(terminal_states$path_probs[grepl("over 150k cob incidence", x = terminal_states$pathname) &
                                                                   startstate.LTBI])

startstate_prob[">150k","LTBI"] <- sum(terminal_states$path_probs[grepl("over 150k cob incidence", x = terminal_states$pathname) &
                                                                  !startstate.LTBI])

knitr::kable(startstate_prob/sum(startstate_prob))
```


## Risk Profile

Further, the pathway probabilities can be used to give the distribution of the terminal state values e.g. cost or time.
This is called the risk profile of the decision tree.

```{r}
osNode <- calc.riskprofile(osNode)
print(osNode, "type", "path_prob", "path_payoff")
```

```{r}
plot(data.frame(osNode$Get('path_payoff', filterFun = isLeaf),
           osNode$Get('path_prob', filterFun = isLeaf)), type="h",
     xlab="payoff", ylab="probability")
```


## Optimal decisions

We can get the software to calculate the optimal decision for us, rather than returning the expections to compare.
This can be done from right to left, iteratively.


```{r eval=FALSE}
##TODO##
osNode$Do(decision, filterFun = function(x) x$type == 'decision')
osNode$Get('decision')[1]
```


```{r eval=FALSE}
##TODO##
## probabilty of successfully & correctly treating LTBI
dummy <- rep(0, osNode$totalCount)
dummy[12] <- 1
osNode$Set(payoff = dummy)
print(osNode, "type", "p", "distn", "mean", "sd", "payoff")
osNode$Do(payoff, traversal = "post-order", filterFun = isNotLeaf)
print(osNode, "type", "p", "distn", "mean", "sd", "payoff")
osNode$Get('payoff')[1]
```

